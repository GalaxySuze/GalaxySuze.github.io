<html>
  <head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>理解「依赖注入」和「控制反转」 | 张阿简的博客</title>
<link rel="shortcut icon" href="VickStar.coding.me/favicon.ico">
<link rel="stylesheet" href="VickStar.coding.me/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="VickStar.coding.me">
  <img class="avatar" src="VickStar.coding.me/images/avatar.png" alt="" width="80px" height="80px">
  </a>
  <h1 class="site-title">
    张阿简的博客
  </h1>
  <p class="site-description">
    Kill Time, Or Kiss Time
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
</div>

      
        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              理解「依赖注入」和「控制反转」
            </h2>
            <div class="post-info">
              <time class="post-time">
                · 2017-06-05 ·
              </time>
              
                <a href="VickStar.coding.me/tag/Zo5YAjmh-" class="post-tags">
                  # 设计模式
                </a>
              
                <a href="VickStar.coding.me/tag/gWr_Ce0M-" class="post-tags">
                  # PHP
                </a>
              
                <a href="VickStar.coding.me/tag/wa6VE0See" class="post-tags">
                  # 原创
                </a>
              
            </div>
            <div class="post-content">
              <h1 id="一. 依赖注入和控制反转是什么？">一. 依赖注入和控制反转是什么？</h1><h4 id="名词解释：">名词解释：</h4><h4 id="ioc">IoC</h4><blockquote>
<ul>
<li>控制反转 Inversion of Control</li>
<li>依赖关系的转移</li>
<li>依赖抽象而非实践</li>
</ul>
</blockquote>
<h4 id="di">DI</h4><blockquote>
<ul>
<li>依赖注入 Dependency Injection</li>
<li>不必自己在代码中维护对象的依赖</li>
<li>容器自动根据配置，将依赖注入指定对象</li>
</ul>
</blockquote>
<h4 id="container">Container</h4><blockquote>
<ul>
<li>管理对象的生成、资源取得、销毁等生命周期</li>
<li>建立对象与对象之间的依赖关系</li>
<li>启动容器后，所有对象直接取用，不用编写任何一行代码来产生对象，或是建立对象之间的依赖关系</li>
</ul>
</blockquote>
<p>------------以上引用自网络</p>
<h1 id="二. ioc代码演示">二. IoC代码演示</h1><p>高层应用程序需要调用底层模块接口,导致高层应用程序对低层模块产生依赖。</p>
<pre><code class="language-php">&lt;?php
    // 高层类
    class Order
    {
        private $track;
        public function __construct()
        {
            $this-&gt;track = new sf();    //顺丰快递
        }

        public function query()
        {
            return $this-&gt;track-&gt;select();
        }
    }
    // 底层类，快递接口
    class sf
    {
        public function select
        {
            return &quot;快递已送达&quot;;
        }
    }
    $order = new Order();
    $order-&gt;query();</code></pre>
<p>假设我们有一个订单类，需要跟踪订单的物流信息，物流目前是和顺丰快递进行合作。但后因种种原因，需要迁移快递物流平台到圆通上去,那现在因为产生了物流接口依赖，程序无法重用，并且必须要修改或者新增圆通快递接口。这就是由于低层模块变化导致高层也跟着变化，不好的设计。</p>
<h4 id="而正如上面的ioc解释">而正如上面的IoC解释</h4><blockquote>
<ul>
<li>控制反转 Inversion of Control</li>
<li>依赖关系的转移</li>
<li>依赖抽象而非实践</li>
</ul>
</blockquote>
<p>程序不应该依赖于具体的实现，而是要依赖抽象的接口。如下：</p>
<pre><code class="language-php">&lt;?php
    // 物流平台接口
    interface trackBox
    {
        public function select();
    }

    // 高层类
    class Order
    {
        private $track;

        public function setTrack($track)
        {
            $this-&gt;track = $track;
        }

        public function query()
        {
            return $this-&gt;track-&gt;select();
        }
    }

    // 底层 顺丰
    class sf implements trackBox
    {
        public function select()
        {
            return &quot;顺丰快递已送达&quot;;
        }
    }

    // 底层 圆通
    class yt implements trackBox
    {
        public function select()
        {
            return &quot;圆通快递已送达&quot;;
        }
    }

    $order = new Order();
    $order-&gt;setTrack(new sf());
    $order-&gt;query(): //顺丰快递已送达

    $order-&gt;setTrack(new yt());
    $order-&gt;query(): //圆通快递已送达</code></pre>
<p>这样就将原来的物流查询模块对程序的控制权转移到trackBox接口上，让order类和各种物流接口类都依赖于trackBox,这样就实现了控制反转。面对变化，高层不用修改一行代码，不再依赖低层，而是依赖注入，这也就引出了(依赖注入)DI。<br/><br>依赖注入的方式有很多，但是主要思想就是如上所示，我们将一个依赖通过注入的方式进行使用。而不是直接将依赖写入被依赖中进行具体的实现。</p>
<h1 id="三. 依赖注入容器 dependency injection container">三. 依赖注入容器 Dependency Injection Container</h1><p>那我们接下来继续思考，如果此后业务扩张，合作的物流平台越来越丰富，那么高层程序依赖的物流接口就会越来越多，我们就需要创建的依赖接口实例也会越来越多，这样就很不利于后期的维护</p>
<pre><code class="language-php">    //底层物流接口
    class sf implements trackBox{ ... } //顺丰
    class yt implements trackBox{ ... } //圆通
    class zt implements trackBox{ ... } //中通
    class yd implements trackBox{ ... } //韵达
    class ems implements trackBox{ ... } //EMS

    //依赖注入
    $order = new Order();
    $order-&gt;setTrack(new sf());
    $order-&gt;select(): //顺丰快递已送达

    $order-&gt;setTrack(new yt());
    $order-&gt;select(): //圆通快递已送达

    $order-&gt;setTrack(new zt());
    $order-&gt;select(): //中通快递已送达

    $order-&gt;setTrack(new yd());
    $order-&gt;select(): //韵达快递已送达

    $order-&gt;setTrack(new ems());
    $order-&gt;select(): //EMS快递已送达</code></pre>
<p>这个时候，我们有一种比较优雅的设计方案就是采用&quot;工厂模式&quot;，</p>
<blockquote>
<p>工厂模式，个人理解就是一个类所依赖的外部实例，可以被一个或多个&quot;工厂&quot;创建的这样一种开发模式</p>
</blockquote>
<p>我们不手动进行创建依赖实例，而是通过工厂去创建依赖实例，我们需要做的只是通过工厂拿到我们需要用到的依赖实例</p>
<pre><code class="language-php">&lt;?php
    // 工厂类
    class TrackFactory
    {
        public function makeTrack($trackName)
        {
            switch ($trackName) {
                case &#39;sf&#39;:     return new sf();
                case &#39;yt&#39;:     return new yt();
                case &#39;zt&#39;:     return new zt();
                case &#39;yd&#39;:     return new yd();
                case &#39;ems&#39;:     return new ems();
            }

            // return new $trackName();
        }
    }

    // 高层类
    class Order
    {
        private $track;

        public function __construct(array $tracks)
        {
            // 初始化工厂类
            $trackFactory = new TrackFactory();
            // 通过工厂类提供的方法制造所需要的物流平台
            foreach ($tracks as $trackName) {
                $this-&gt;$track[] = $trackFactory-&gt;makeTrack($trackName);
            }
        }

        public function query($trackName)
        {
            return $this-&gt;track[$trackName]-&gt;select();
        }
    }

    $Order = new Order([&#39;sf&#39;,&#39;yd&#39;,&#39;ems&#39;,&#39;zt&#39;,]);
    $Order-&gt;query(&#39;sf&#39;);
    $Order-&gt;query(&#39;yd&#39;);
    $Order-&gt;query(&#39;ems&#39;);
</code></pre>
<p>尽管工厂模式让我们的代码变得优雅了一点，但是我们又回到了开头的错误中来，我们现在对工厂类进行了依赖,并且在物流接口愈加丰富后，工厂类也会慢慢变的冗长而不利于维护，那我们要怎么才能设计出一套即优雅又松耦合的应用程序呢？这个时候就需要有容器这个概念</p>
<h4 id="container">Container</h4><blockquote>
<ul>
<li>管理对象的生成、资源取得、销毁等生命周期</li>
<li>建立对象与对象之间的依赖关系</li>
<li>启动容器后，所有对象直接取用，不用编写任何一行代码来产生对象，或是建立对象之间的依赖关系</li>
</ul>
</blockquote>
<pre><code class="language-php">&lt;?php
    // 容器类
    class Container
    {
        protected $binds;
        public function bind($service, $instance)
        {
            if ($concrete instanceof Closure) {
                $this-&gt;binds[$service] = $instance;
            }
        }

        public function make($service, $parameters)
        {
            return call_user_func_array([$this-&gt;binds[$service],], $parameters);
        }
    }

    // 高层类
    class Order
    {
        private $track;

        public function __construct($track)
        {
            $this-&gt;track = $track;
        }

        public function query()
        {
            return $this-&gt;track-&gt;select();
        }
    }

    $container = new Container();
    $container-&gt;bind(&#39;sf&#39;, function($container) {
        return new sf();
    });
    $container-&gt;bind(&#39;Order&#39;, function($container) {
        return new Order();
    });

    $Order = $container-&gt;make(&#39;Order&#39;,&#39;sf&#39;);
</code></pre>

            </div>
          </article>
        </div>
    
        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="VickStar.coding.me/post/mac-xia-an-zhuang-redis-he-php-redis-kuo-zhan">
              <h3 class="post-title">
                Mac下安装Redis和php-redis扩展
              </h3>
            </a>
          </div>  
        

        
    
        <div class="site-footer">
  Powered by Hve Notes, © 2017 - 2019 Copyright 张阿简. All Rights Reserved.
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

      </div>
    </div>
  </body>
</html>
